#pragma once
#include <meta>
#include <string_view>
#include <vector>
#include <tuple>
#include <type_traits>
#include <utility>
#include <ranges>
#include <cstddef>

#include <rsl/string_constant>
#include <rsl/_impl/parser.hpp>
#include <rsl/_impl/member_cache.hpp>

namespace rsl {

template <typename Impl>
struct [[nodiscard]] kwargs_t : Impl {
  using type                          = Impl;
  static constexpr auto _member_cache = [:_impl::cache_members(nonstatic_data_members_of(
                                              ^^Impl,
                                              std::meta::access_context::unchecked())):];
};

template <typename T>
concept is_kwargs = has_template_arguments(^^T) && template_of(^^T) == ^^kwargs_t;

namespace kwargs {
struct NameParser : _impl::Parser {
  using _impl::Parser::Parser;

  std::vector<std::string_view> names;

  constexpr bool parse() {
    cursor = 0;

    while (is_valid()) {
      skip_whitespace();

      if (current() == '&') {
        // might be captured by reference
        ++cursor;
        skip_whitespace();
      }

      if (current() == '.') {
        // pack captured, reject
        return false;
      }

      std::size_t start = cursor;

      // find '=', ',' or whitespace
      skip_to('=', ',', ' ', '\n', '\r', '\t');
      if (cursor - start == 0) {
        // default capture or invalid name
        return false;
      }

      auto name = data.substr(start, cursor - start);
      if (name == "this" || name == "*this") {
        // this captured, reject
        return false;
      }
      names.emplace_back(name);

      // skip ahead to next capture
      // if the current character is already ',', this will not move the cursor
      skip_to(',');
      ++cursor;

      skip_whitespace();
    }
    return true;
  }
};

template <string_constant Names, typename... Ts>
constexpr auto make(Ts&&... values) {
  struct kwargs_impl;
  consteval {
    std::vector<std::meta::info> types{^^Ts...};
    std::vector<std::meta::info> args;

    auto parser = NameParser(Names);

    // with P3068 parser.parse() could throw to provide better diagnostics at this point
    if (!parser.parse()) {
      return;
    }

    // associate every argument with the corresponding name
    // retrieved by parsing the capture list

    // std::views::zip_transform could also be used for this
    for (auto [member, name] : std::views::zip(types, parser.names)) {
      args.push_back(data_member_spec(member, {.name = name}));
    }
    define_aggregate(^^kwargs_impl, args);
  };

  // ensure injecting the class worked
  static_assert(is_type(^^kwargs_impl), std::string{"Invalid keyword arguments `"} + Names + "`");

  return kwargs_t<kwargs_impl>{{std::forward<Ts>(values)...}};
}
}  // namespace kwargs

template <string_constant Names, typename... Ts>
constexpr auto make_args(Ts&&... values) {
  return kwargs::make<Names>(std::forward<Ts>(values)...);
}

template <typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
consteval bool has_arg(std::string_view name) {
  return std::remove_cvref_t<T>::_member_cache.has_member(name);
}

// get

template <std::size_t Idx, typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get(T&& kwargs) noexcept {
  static_assert(std::remove_cvref_t<T>::_member_cache.count > Idx);
  return std::remove_cvref_t<T>::_member_cache.template get<Idx>(std::forward<T>(kwargs));
}

template <string_constant name, typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get(T&& kwargs) {
  static_assert(has_arg<T>(name), "Keyword argument `" + std::string(name) + "` not found.");

  static constexpr auto Idx = std::remove_cvref_t<T>::_member_cache.get_index_of(name);
  return get<Idx>(std::forward<T>(kwargs));
}

// get_or
template <std::size_t Idx, typename T, typename R>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get_or(T&& kwargs, R default_) noexcept {
  using kwarg_tuple = std::remove_cvref_t<T>;
  if constexpr (kwarg_tuple::_member_cache.count > Idx) {
    return get<Idx>(std::forward<T>(kwargs));
  } else {
    return default_;
  }
}

template <string_constant name, typename T, typename R>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get_or(T&& kwargs, R default_) {
  using kwarg_tuple = std::remove_cvref_t<T>;
  if constexpr (kwarg_tuple::_member_cache.count >
                std::remove_cvref_t<T>::_member_cache.get_index_of(name)) {
    return get<name>(std::forward<T>(kwargs));
  } else {
    return default_;
  }
}
}  // namespace rsl

template <typename T>
struct std::tuple_size<rsl::kwargs_t<T>>
    : public integral_constant<size_t, rsl::kwargs_t<std::remove_cvref_t<T>>::_member_cache.count> {
};

template <std::size_t Idx, typename T>
struct std::tuple_element<Idx, rsl::kwargs_t<T>> {
  using type = [:rsl::kwargs_t<std::remove_cvref_t<T>>::_member_cache.types[Idx]:];
};

#define RSL_KWARGS(...)                                                                            \
  [__VA_ARGS__]<typename T>(this T _impl_this) {                                                   \
    constexpr static auto _impl_captures =                                                         \
        define_static_array(nonstatic_data_members_of(^^T, std::meta::access_context::current())); \
    return [&]<std::size_t... Idx>(std::index_sequence<Idx...>) {                                  \
      return rsl::kwargs::make<#__VA_ARGS__>(                                                      \
          std::forward<decltype(_impl_this.[:_impl_captures[Idx]:])>(                              \
              _impl_this.[:_impl_captures[Idx]:])...);                                             \
    }(std::make_index_sequence<_impl_captures.size()>());                                          \
  }()

#define $args(...) RSL_KWARGS(__VA_ARGS__)