#pragma once
#include <meta>
#include <string_view>
#include <vector>
#include <tuple>
#include <type_traits>
#include <utility>
#include <ranges>
#include <cstddef>

#include <rsl/string_constant>
#include <rsl/meta>

#include <rsl/_impl/parser.hpp>
#include <rsl/_impl/member_cache.hpp>

namespace rsl {

template <typename Impl>
struct [[nodiscard]] kwargs_t : Impl {
  using type                          = Impl;
  static constexpr auto _member_cache = [:_impl::cache_members(nonstatic_data_members_of(
                                              ^^Impl,
                                              std::meta::access_context::unchecked())):];
};

template <typename T>
concept is_kwargs = has_template_arguments(^^T) && template_of(^^T) == ^^kwargs_t;

namespace kwargs {
struct parse_error : std::logic_error {
  using std::logic_error::logic_error;
};

struct NameParser : _impl::Parser {
  using _impl::Parser::Parser;
  std::vector<std::string_view> names;

  constexpr bool parse() {
    cursor = 0;

    while (is_valid()) {
      skip_whitespace();
      std::size_t start = cursor;
      skip_to('=', ',', ' ', '\n', '\r', '\t');
      if (cursor - start == 0) {
        // invalid name
        return false;
      }
      names.emplace_back(data.substr(start, cursor - start));

      // skip ahead to next arg
      // if the current character is already ',', this will not move the cursor
      skip_to(',');
      ++cursor;

      skip_whitespace();
    }
    return true;
  }
};

struct Arg {
  template <typename T>
  decltype(auto) operator=(T&& value) const {
    return std::forward<T>(value);
  }
};

consteval std::meta::info make_detector_type(std::string_view Names) {
  auto parser = NameParser(Names);
  if (not parser.parse()) {
    throw parse_error("could not parse argument list");
  }
  return rsl::meta::inject_aggregate(parser.names | std::views::transform([](auto name) {
                                 return data_member_spec(^^Arg, {.name = name});
                               }));
}

template <string_constant C>
using detector = typename[:rsl::kwargs::make_detector_type(C):];

template <string_constant Expr, typename... Ts>
consteval auto inject_wrapper() {
  std::vector<std::meta::info> args;
  auto members =
      nonstatic_data_members_of(^^detector<Expr>, std::meta::access_context::unprivileged());
  for (auto [member, type] : std::views::zip(members, std::vector<std::meta::info>{^^Ts...})) {
    args.push_back(data_member_spec(remove_cvref(type), {.name = identifier_of(member)}));
  }

  return rsl::meta::inject_aggregate(args);
}

template <string_constant Expr, typename... Ts>
constexpr auto make(Ts&&... values) {
  static_assert(((not std::same_as<std::remove_cvref_t<Ts>, Arg>) && ...));

  using container = kwargs_t<typename[:inject_wrapper<Expr, std::remove_cvref_t<Ts>...>():]>;
  return container{{std::forward<Ts>(values)...}};
}
}  // namespace kwargs

template <typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
consteval bool has_arg(std::string_view name) {
  return std::remove_cvref_t<T>::_member_cache.has_member(name);
}

// get

template <std::size_t Idx, typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get(T&& kwargs) noexcept {
  static_assert(std::remove_cvref_t<T>::_member_cache.count > Idx);
  return std::remove_cvref_t<T>::_member_cache.template get<Idx>(std::forward<T>(kwargs));
}

template <string_constant name, typename T>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get(T&& kwargs) {
  static_assert(has_arg<T>(name), "Keyword argument `" + std::string(name) + "` not found.");

  static constexpr auto Idx = std::remove_cvref_t<T>::_member_cache.get_index_of(name);
  return get<Idx>(std::forward<T>(kwargs));
}

// get_or
template <std::size_t Idx, typename T, typename R>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get_or(T&& kwargs, R default_) noexcept {
  using kwarg_tuple = std::remove_cvref_t<T>;
  if constexpr (kwarg_tuple::_member_cache.count > Idx) {
    return get<Idx>(std::forward<T>(kwargs));
  } else {
    return default_;
  }
}

template <string_constant name, typename T, typename R>
  requires is_kwargs<std::remove_cvref_t<T>>
constexpr auto get_or(T&& kwargs, R default_) {
  using kwarg_tuple = std::remove_cvref_t<T>;
  if constexpr (kwarg_tuple::_member_cache.count >
                std::remove_cvref_t<T>::_member_cache.get_index_of(name)) {
    return get<name>(std::forward<T>(kwargs));
  } else {
    return default_;
  }
}
}  // namespace rsl

template <typename T>
struct std::tuple_size<rsl::kwargs_t<T>>
    : public integral_constant<size_t, rsl::kwargs_t<std::remove_cvref_t<T>>::_member_cache.count> {
};

template <std::size_t Idx, typename T>
struct std::tuple_element<Idx, rsl::kwargs_t<T>> {
  using type = [:rsl::kwargs_t<std::remove_cvref_t<T>>::_member_cache.types[Idx]:];
};

#define RSL_KWARGS_IDENTITY(x)   x
#define RSL_KWARGS_EXPAND_ONE(d) rsl::kwargs::detector<d>{}.RSL_KWARGS_IDENTITY

#define $args(...) \
  rsl::kwargs::make<#__VA_ARGS__>($for_each(RSL_KWARGS_EXPAND_ONE(#__VA_ARGS__), __VA_ARGS__))
