#pragma once

#include <meta>
#include <concepts>
#include <format>
#include <string>
#include <functional>

#include <rsl/utility>
#include <rsl/meta_traits>

#include <rsl/_impl/concepts.hpp>
#include <rsl/util/operators.hpp>
#include <rsl/util/to_string.hpp>

namespace rsl::_expect_impl {
template <typename T>
consteval auto consteval_wrap(T const& value) {
  // this hack is required to compare against string literals
  // in expect annotations
  if constexpr (std::convertible_to<T, std::string_view>) {
    return std::define_static_string(value);
  } else {
    return value;
  }
}

template <typename T>
using wrapped_t = decltype(consteval_wrap(std::declval<T>()));

struct Operator {
  std::meta::operators op;

  Operator() = delete;
  constexpr Operator(std::convertible_to<std::string_view> auto str) : op(util::to_operator(str)) {}
  constexpr Operator(std::meta::operators op) : op(op) {}
  constexpr ~Operator() {}

  constexpr operator std::meta::operators() const { return op; }
};

constexpr bool matches(std::meta::operators op, std::convertible_to<Operator> auto... operators) {
  auto [... needle] = std::array{operators...};
  return ((op == Operator(needle)) || ...);
}

constexpr bool is_comparison(std::meta::operators op) {
  // spaceship not supported
  return matches(op, "<", "<=", ">", ">=", "==", "!=");
}

template <std::meta::operators OP, typename R, typename L>
struct BinaryExpr;

template <Operator OP, typename R, typename L>
constexpr auto make_expr(R rhs_, L lhs_) {
  return BinaryExpr<OP, R, L>{rhs_, lhs_};
}

template <typename T>
concept is_binary_expr = meta::specializes<T, ^^BinaryExpr>;

template <typename T>
concept is_binary_comparison = is_binary_expr<T> && is_comparison(T::op);

template <std::meta::operators OP, typename R, typename L>
struct BinaryExpr {
  static constexpr auto op = OP;
  R rhs;
  L lhs;

  constexpr auto get_left_most() const {
    if constexpr (meta::specializes<L, ^^BinaryExpr>) {
      return lhs.get_left_most();
    } else {
      return lhs;
    }
  }

  constexpr auto get_right_most() const {
    if constexpr (meta::specializes<R, ^^BinaryExpr>) {
      return rhs.get_right_most();
    } else {
      return rhs;
    }
  }

  template <typename T>
  constexpr decltype(auto) eval(T&& args) const {
    auto descend = [&](auto&& obj) {
      constexpr auto evaluatable = requires {
        { obj.eval(std::forward<T>(args)) } -> _impl::is_non_void;
      };

      if constexpr (evaluatable) {
        return obj.eval(std::forward<T>(args));
      } else {
        return obj;
      }
    };

    return eval_operator(descend(std::forward_like<T>(lhs)), descend(std::forward_like<T>(rhs)));
  }

  template <typename T>
  constexpr auto eval_verbose(T&& args, std::vector<std::string>& failed_terms) const {
    auto descend = [&](auto&& obj) {
      constexpr auto evaluatable = requires {
        { obj.eval_verbose(std::forward<T>(args), failed_terms) } -> _impl::is_non_void;
      };

      if constexpr (evaluatable) {
        return obj.eval_verbose(std::forward<T>(args), failed_terms);
      } else {
        return obj;
      }
    };

    auto result =
        eval_operator(descend(std::forward_like<T>(lhs)), descend(std::forward_like<T>(rhs)));
    if (!result) {
      failed_terms.push_back(to_string(args));
    }
    return result;
  }

  constexpr std::string to_string(auto const& args) const {
    // TODO constexpr
    static constexpr bool rhs_printable = requires {
      { rhs.to_string(args) } -> std::same_as<std::string>;
    };
    static constexpr bool lhs_printable = requires {
      { lhs.to_string(args) } -> std::same_as<std::string>;
    };

    if constexpr (rhs_printable && lhs_printable) {
      return std::format("({} {} {})",
                         rhs.to_string(args),
                         util::to_string(OP),
                         lhs.to_string(args));
    } else if constexpr (rhs_printable) {
      return std::format("({} {} {})", rhs.to_string(args), util::to_string(OP), lhs);
    } else if constexpr (lhs_printable) {
      return std::format("({} {} {})", rhs, util::to_string(OP), lhs.to_string(args));
    }
  }

  constexpr std::string to_string(std::vector<std::string_view> const& replacements) const {
    static constexpr bool rhs_printable = requires {
      { rhs.to_string(replacements) } -> std::same_as<std::string>;
    };
    static constexpr bool lhs_printable = requires {
      { lhs.to_string(replacements) } -> std::same_as<std::string>;
    };

    if constexpr (rhs_printable && lhs_printable) {
      return std::string("(") + rhs.to_string(replacements) + " " + util::to_string(OP) + " " +
             lhs.to_string(replacements) + ")";
    } else if constexpr (rhs_printable) {
      return std::string("(") + rhs.to_string(replacements) + " " + util::to_string(OP) + " " +
             util::to_string(lhs) + ")";
    } else if constexpr (lhs_printable) {
      return std::string("(") + util::to_string(rhs) + " " + util::to_string(OP) + " " +
             lhs.to_string(replacements) + ")";
    }
  }

  template <typename T2, typename T1>
  static constexpr decltype(auto) eval_operator(T1&& rhs, T2&& lhs) {
    // TODO args are flipped - why?
    using enum std::meta::operators;
    /* */ if constexpr (OP == op_plus) {
      return std::forward<T1>(lhs) + std::forward<T2>(rhs);
    } else if constexpr (OP == op_minus) {
      return std::forward<T1>(lhs) - std::forward<T2>(rhs);
    } else if constexpr (OP == op_star) {
      return std::forward<T1>(lhs) * std::forward<T2>(rhs);
    } else if constexpr (OP == op_slash) {
      return std::forward<T1>(lhs) / std::forward<T2>(rhs);
    } else if constexpr (OP == op_percent) {
      return std::forward<T1>(lhs) % std::forward<T2>(rhs);
    } else if constexpr (OP == op_caret) {
      return std::forward<T1>(lhs) ^ std::forward<T2>(rhs);
    } else if constexpr (OP == op_ampersand) {
      return std::forward<T1>(lhs) & std::forward<T2>(rhs);
    } else if constexpr (OP == op_pipe) {
      return std::forward<T1>(lhs) | std::forward<T2>(rhs);
    } else if constexpr (OP == op_equals) {
      return std::forward<T1>(lhs) = std::forward<T2>(rhs);
    } else if constexpr (OP == op_plus_equals) {
      return std::forward<T1>(lhs) += std::forward<T2>(rhs);
    } else if constexpr (OP == op_minus_equals) {
      return std::forward<T1>(lhs) -= std::forward<T2>(rhs);
    } else if constexpr (OP == op_star_equals) {
      return std::forward<T1>(lhs) *= std::forward<T2>(rhs);
    } else if constexpr (OP == op_slash_equals) {
      return std::forward<T1>(lhs) /= std::forward<T2>(rhs);
    } else if constexpr (OP == op_percent_equals) {
      return std::forward<T1>(lhs) %= std::forward<T2>(rhs);
    } else if constexpr (OP == op_caret_equals) {
      return std::forward<T1>(lhs) ^= std::forward<T2>(rhs);
    } else if constexpr (OP == op_ampersand_equals) {
      return std::forward<T1>(lhs) &= std::forward<T2>(rhs);
    } else if constexpr (OP == op_pipe_equals) {
      return std::forward<T1>(lhs) |= std::forward<T2>(rhs);
    } else if constexpr (OP == op_equals_equals) {
      return std::forward<T1>(lhs) == std::forward<T2>(rhs);
    } else if constexpr (OP == op_exclamation_equals) {
      return std::forward<T1>(lhs) != std::forward<T2>(rhs);
    } else if constexpr (OP == op_less) {
      return std::forward<T1>(lhs) < std::forward<T2>(rhs);
    } else if constexpr (OP == op_greater) {
      return std::forward<T1>(lhs) > std::forward<T2>(rhs);
    } else if constexpr (OP == op_less_equals) {
      return std::forward<T1>(lhs) <= std::forward<T2>(rhs);
    } else if constexpr (OP == op_greater_equals) {
      return std::forward<T1>(lhs) >= std::forward<T2>(rhs);
    } else if constexpr (OP == op_spaceship) {
      return std::forward<T1>(lhs) <=> std::forward<T2>(rhs);
    } else if constexpr (OP == op_ampersand_ampersand) {
      return std::forward<T1>(lhs) && std::forward<T2>(rhs);
    } else if constexpr (OP == op_pipe_pipe) {
      return std::forward<T1>(lhs) || std::forward<T2>(rhs);
    } else if constexpr (OP == op_less_less) {
      return std::forward<T1>(lhs) << std::forward<T2>(rhs);
    } else if constexpr (OP == op_greater_greater) {
      return std::forward<T1>(lhs) >> std::forward<T2>(rhs);
    } else if constexpr (OP == op_less_less_equals) {
      return std::forward<T1>(lhs) <<= std::forward<T2>(rhs);
    } else if constexpr (OP == op_greater_greater_equals) {
      return std::forward<T1>(lhs) >>= std::forward<T2>(rhs);
    } else if constexpr (OP == op_comma) {
      return std::forward<T1>(lhs), std::forward<T2>(rhs);
    }
  }

  constexpr auto transform() const { return *this; }

  constexpr auto transform() const
    requires is_binary_comparison<BinaryExpr>
  {
    if constexpr (is_binary_comparison<R> && is_binary_comparison<L>) {
      return make_expr<"&&">(
          make_expr<"&&">(rhs.transform(),
                          make_expr<op>(rhs.get_left_most(), lhs.get_right_most())),
          lhs.transform());
    } else if constexpr (is_binary_comparison<R>) {
      return make_expr<"&&">(rhs.transform(), make_expr<op>(rhs.get_left_most(), lhs));
    } else if constexpr (is_binary_comparison<L>) {
      return make_expr<"&&">(make_expr<op>(rhs, lhs.get_right_most()), lhs.transform());
    } else {
      return *this;
    }
  }
};

namespace _impl {
template <auto V>
struct value {};

template <typename T>
constexpr inline auto non_special_members =
    define_static_array(members_of(^^T, std::meta::access_context::current()) |
                        std::views::filter([](std::meta::info R) {
                          return (is_function(R) or is_nonstatic_data_member(R)) and
                                 not is_special_member_function(R);
                        }));

template <std::size_t Idx, typename T>
decltype(auto) operator->*(T&& obj, value<Idx>) {
  static constexpr auto member = non_special_members<std::remove_cvref_t<T>>[Idx];
  // if constexpr (is_function(member)) {
  //   // TODO check for getter annotation
  //   if constexpr (is_static_member(member)) {
  //     return [:member:];
  //   } else {
  //     return [&]<typename... Ts>(Ts&&... args) {
  //       return std::forward<T>(obj).[:member:](std::forward<Ts>(args)...);
  //     };
  //   }
  // } else 
  if constexpr (is_nonstatic_data_member(member)) {
    return std::forward<T>(obj).[:member:];
  } else if constexpr (requires {
                         { get<Idx>(std::forward<T>(obj)) };
                       }) {
    return get<Idx>(std::forward<T>(obj));
  } else {
    static_assert(false, std::string("Cannot get member") + util::utos(Idx));
  }
}
}  // namespace _impl

template <std::size_t... Idx>
struct Placeholder {
  template <typename T>
  constexpr decltype(auto) eval(T&& args) const {
    return (std::forward<T>(args)->*...->*_impl::value<Idx>{});
  }

  template <typename T>
  constexpr auto eval_verbose(T&& args, std::vector<std::string>& failed_terms) const {
    return eval(std::forward<T>(args));
  }

  template <typename T>
  constexpr std::string to_string(T&& args) const {
    // TODO constexpr
    if constexpr (requires {
                    { std::format("{}", eval(std::forward<T>(args))) };
                  }) {
      return std::format("{}", eval(std::forward<T>(args)));
    }
    // TODO emit type name
    return "<obj>";
  }

  constexpr std::string to_string(std::vector<std::string_view> const& replacements) const {
    // TODO emit member names
    return std::string(replacements[Idx...[0]]);
  }

  // TODO wrap call and subscript
};

template <typename T, std::size_t... I>
struct PlaceholderFor {
  struct Lazy;

  consteval {
    std::vector<std::meta::info> members;
    auto idx = 0;
    for (auto member : _impl::non_special_members<std::remove_cvref_t<T>>) {
      std::meta::info type;
      if (is_class_type(remove_cvref(type_of(member)))) {
        type = substitute(^^PlaceholderFor,
                          {remove_cvref(type_of(member)),
                           std::meta::reflect_constant(I)...,
                           std::meta::reflect_constant(idx++)});
      } else {
        // TODO does this need special handling for functions?
        type = substitute(^^Placeholder,
                          {std::meta::reflect_constant(I)..., std::meta::reflect_constant(idx++)});
      }

      members.push_back(data_member_spec(type, {.name = identifier_of(member)}));
    }
    define_aggregate(^^Lazy, members);
  }

  Lazy* operator->() const { return nullptr; }
};

template <typename T>
struct Wrapped {
  T value;
  constexpr decltype(auto) eval(auto const& args) const { return value; }

  constexpr auto eval_verbose(auto const& args, std::vector<std::string>& failed_terms) const {
    return eval(args);
  }

  constexpr std::string to_string(auto const& args) const { return util::to_string(value); }

  constexpr std::string to_string(std::vector<std::string_view> const& replacements) const {
    return util::to_string(value);
  }
};

template <typename F, typename... Args>
struct Lazy {
  F callable;
  std::tuple<Args...> arguments;

  template <std::size_t Idx, bool verbose = false>
  constexpr decltype(auto) expand_args(auto const& args,
                                       std::vector<std::string>& failed_terms) const {
    using wrapped_t = Args...[Idx];
    if constexpr (verbose && requires(wrapped_t obj) { obj.eval_verbose(args, failed_terms); }) {
      return get<Idx>(arguments).eval_verbose(args, failed_terms);
    } else if constexpr (requires(wrapped_t obj) { obj.eval(args); }) {
      return get<Idx>(arguments).eval(args);
    } else {
      return get<Idx>(arguments);
    }
  }

  constexpr decltype(auto) eval(auto const& args) const {
    return [&]<std::size_t... Idx>(std::index_sequence<Idx...>) {
      return callable(expand_args<Idx>(args)...);
    }(std::make_index_sequence<sizeof...(Args)>());
  }

  constexpr auto eval_verbose(auto const& args, std::vector<std::string>& failed_terms) const {
    return eval(args);
  }

  constexpr std::string to_string(auto const& args) const { return "<lazy call>"; }
  constexpr std::string to_string(std::vector<std::string_view> const&) const {
    return "<lazy call>";
  }
};

template <typename T>
concept is_expr_tree = meta::specializes<T, ^^Wrapped> || meta::specializes<T, ^^BinaryExpr> ||
                       meta::specializes<T, ^^Placeholder> || meta::specializes<T, ^^Lazy>;

#define $make_op(op)                                                           \
  template <typename T>                                                        \
    requires(!is_expr_tree<T>)                                                 \
  constexpr auto operator op(is_expr_tree auto rhs_, T lhs_) {                 \
    if consteval {                                                             \
      return make_expr<#op>(rhs_, consteval_wrap(lhs_));                       \
    } else {                                                                   \
      return make_expr<#op>(rhs_, lhs_);                                       \
    }                                                                          \
  }                                                                            \
  template <typename T>                                                        \
    requires(!is_expr_tree<T>)                                                 \
  constexpr auto operator op(T rhs_, is_expr_tree auto lhs_) {                 \
    if consteval {                                                             \
      return make_expr<#op>(consteval_wrap(rhs_), lhs_);                       \
    } else {                                                                   \
      return make_expr<#op>(rhs_, lhs_);                                       \
    }                                                                          \
  }                                                                            \
  constexpr auto operator op(is_expr_tree auto rhs_, is_expr_tree auto lhs_) { \
    return make_expr<#op>(rhs_, lhs_);                                         \
  }

$make_op(<);
$make_op(<=);
$make_op(>);
$make_op(>=);
$make_op(==);
$make_op(!=);

$make_op(&&);
$make_op(||);

$make_op(/);
$make_op(*);
$make_op(%);
$make_op(+);
$make_op(-);

$make_op(<<);
$make_op(>>);

template <typename... Args>
struct FunctionArgs {
  std::tuple<Args...> args;

  template <typename F>
  friend constexpr auto operator%(F fnc, FunctionArgs partial) {
    return Lazy{fnc, partial.args};
  }
};

auto lazy(auto... args) {
  return FunctionArgs{std::tuple{args...}};
}

template <typename T>
struct Expect : T {
  constexpr auto transform() {
    if constexpr (meta::specializes<T, ^^BinaryExpr>) {
      return rsl::_expect_impl::Expect{T::transform()};
    } else {
      return *this;
    }
  }
  constexpr std::string to_string(std::string_view replacement = "value") const {
    return T::to_string(std::vector{replacement});
  }

  template <typename... Args>
  constexpr bool operator()(Args&&... args) const {
    return this->eval(std::tuple(std::forward<Args>(args)...));
  }

  template <typename... Args>
  constexpr operator std::function<bool(Args&&...)>() const {
    return std::bind(&Expect::template operator()<Args...>, *this);
  }
};

constexpr auto expect(auto expr) {
  // the point of this function is to be found via ADL
  return Expect{expr}.transform();
}

constexpr inline struct {
  template <typename T>
  constexpr auto operator->*(T other) const {
    return Wrapped{other};
  }
} decompose{};

}  // namespace rsl::_expect_impl

#define $lazy(fnc)                                                              \
  [](auto... args) {                                                            \
    return rsl::_expect_impl::Lazy{[](auto... args_) { return fnc(args_...); }, \
                                   std::tuple{args...}};                        \
  }

namespace rsl {
// using rsl::_expect_impl::expect;
using rsl::_expect_impl::Placeholder;
template <typename T, std::size_t Idx>
using TypedPlaceholder = _expect_impl::PlaceholderFor<T, Idx>;

namespace typed_placeholders {
template <typename T>
constexpr inline TypedPlaceholder<T, 0> _0{};
template <typename T>
constexpr inline TypedPlaceholder<T, 1> _1{};
template <typename T>
constexpr inline TypedPlaceholder<T, 2> _2{};
template <typename T>
constexpr inline TypedPlaceholder<T, 3> _3{};
template <typename T>
constexpr inline TypedPlaceholder<T, 4> _4{};
template <typename T>
constexpr inline TypedPlaceholder<T, 5> _5{};
template <typename T>
constexpr inline TypedPlaceholder<T, 6> _6{};
template <typename T>
constexpr inline TypedPlaceholder<T, 7> _7{};
template <typename T>
constexpr inline TypedPlaceholder<T, 8> _8{};
template <typename T>
constexpr inline TypedPlaceholder<T, 9> _9{};
}  // namespace typed_placeholders

namespace placeholders {
template <typename T>
constexpr inline auto p0 = typed_placeholders::_0<T>;
template <typename T>
constexpr inline auto p1 = typed_placeholders::_1<T>;
template <typename T>
constexpr inline auto p2 = typed_placeholders::_2<T>;
template <typename T>
constexpr inline auto p3 = typed_placeholders::_3<T>;
template <typename T>
constexpr inline auto p4 = typed_placeholders::_4<T>;
template <typename T>
constexpr inline auto p5 = typed_placeholders::_5<T>;
template <typename T>
constexpr inline auto p6 = typed_placeholders::_6<T>;
template <typename T>
constexpr inline auto p7 = typed_placeholders::_7<T>;
template <typename T>
constexpr inline auto p8 = typed_placeholders::_8<T>;
template <typename T>
constexpr inline auto p9 = typed_placeholders::_9<T>;

constexpr inline Placeholder<0> _0{};
constexpr inline Placeholder<1> _1{};
constexpr inline Placeholder<2> _2{};
constexpr inline Placeholder<3> _3{};
constexpr inline Placeholder<4> _4{};
constexpr inline Placeholder<5> _5{};
constexpr inline Placeholder<6> _6{};
constexpr inline Placeholder<7> _7{};
constexpr inline Placeholder<8> _8{};
constexpr inline Placeholder<9> _9{};
}  // namespace placeholders
}  // namespace rsl