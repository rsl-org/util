#pragma once
#include <algorithm>
#include <meta>
#include <ranges>

#include <rsl/macro>

namespace rsl::meta {

consteval bool is_specialization(std::meta::info type, std::meta::info templ) {
  if (not is_type(type)) {
    throw "not a type";
  }
  return has_template_arguments(type) &&
         template_of(type) == (is_template(templ) ? templ : template_of(templ));
}

using std::meta::is_function;

consteval bool is_member_function(std::meta::info r) {
  return is_function(r) && is_class_member(r);
}

consteval bool is_static_member_function(std::meta::info r) {
  return is_member_function(r) && is_static_member(r);
}

consteval bool is_nonstatic_member_function(std::meta::info r) {
  return is_member_function(r) && !is_static_member(r);
}

namespace _compat {
consteval std::vector<std::meta::info> annotations_of_with_type(std::meta::info r,
                                                                std::meta::info t) {
#if $compiler_is(CLANG)
  return std::meta::annotations_of(r, t);
#else
  return std::meta::annotations_of_with_type(r, t);
#endif
}
}  // namespace _compat

template <typename T>
consteval bool has_annotation(std::meta::info item) {
  return !_compat::annotations_of_with_type(item, ^^T).empty();
}

consteval bool has_annotation(std::meta::info item, std::meta::info type) {
  if (is_type(type)) {
    return !_compat::annotations_of_with_type(item, type).empty();
  } else if (is_template(type)) {
    for (auto annotation : annotations_of(item)) {
      if (has_template_arguments(type_of(annotation)) && template_of(type_of(annotation)) == type) {
        return true;
      }
    }
  }
  return false;
}

template <typename T>
consteval bool has_annotation(std::meta::info item, T const& value) {
  if (!has_annotation<T>(item)) {
    return false;
  }
  auto annotations = _compat::annotations_of_with_type(item, dealias(^^T));
  auto value_r     = std::meta::reflect_constant(value);
  return std::ranges::any_of(annotations, [&](auto annotation) { return annotation == value_r; });
}

consteval std::vector<std::meta::info> get_annotations(std::meta::info item, std::meta::info type) {
  std::vector<std::meta::info> annotations;
  for (auto annotation : annotations_of(item)) {
    if ((is_type(type) && type == type_of(annotation)) ||
        (is_template(type) && has_template_arguments(type_of(annotation)) &&
         template_of(type_of(annotation)) == type)) {
      annotations.push_back(annotation);
    }
  }
  return annotations;
}

consteval std::meta::info get_annotation(std::meta::info item, std::meta::info type) {
  return get_annotations(item, type)[0];
}

consteval bool has_parent(std::meta::info R) {
  // HACK remove this once `std::meta::has_parent` is supported in libc++
  return R != ^^::;
}


consteval std::meta::info get_member_by_name(std::meta::info r, std::string_view name) {
  for (auto member : members_of(r, std::meta::access_context::unprivileged())) {
    if (has_identifier(member) && identifier_of(member) == name) {
      return member;
    }
  }
  return {};
}

namespace _impl {
template <std::meta::info... Args>
struct injected {
  struct type;
  consteval { define_aggregate(^^type, {Args...}); };

  static_assert(is_complete_type(^^type));
};
}  // namespace _impl

consteval std::meta::info inject_aggregate(std::meta::reflection_range auto&& fields) {
  auto wrapper = substitute(^^_impl::injected, fields | std::views::transform([](auto r) {
                                                 return std::meta::reflect_constant(r);
                                               }));
  auto type    = get_member_by_name(wrapper, "type");
  return is_type(type) ? type : throw "not a type";
}
}  // namespace rsl::meta