#pragma once
#include <functional>
#include <ranges>
#include <rsl/meta_traits>

#include "serializer/machinery.hpp"
#include "serializer/name.hpp"
#include "serializer/binary.hpp"

#include "stream/stream.hpp"
#include "stream/memory.hpp"

namespace rsl {

using serializer::NameMode;
using serializer::preferred_name;

using serializer::type_name;
using serializer::unqualified_name;
using serializer::qualified_name;
using serializer::fully_qualified_name;
using serializer::name_of;
using serializer::unqualified_name_of;
using serializer::qualified_name_of;
using serializer::fully_qualified_name_of;

template <typename T>
using to_owning = typename serializer::Meta<T>::owning_type;

template <typename T, typename V>
constexpr void serialize(T&& serializer, V&& data) {
  std::invoke(serializer, serializer::Meta<std::remove_cvref_t<V>>{}, std::forward<V>(data));
}

template <meta::complete_type V, typename T, std::ranges::forward_range R>
constexpr V deserialize(T&& deserializer, R&& data) {}

template <typename T, meta::complete_type V>
constexpr void serialize_type(T&& serializer) {
  return serializer.template operator()<^^V>();
}

template <typename T, std::ranges::forward_range R>
consteval std::meta::info deserialize_type(T&& deserializer, R&& data) {
  return deserializer(data);
}

enum struct Endianess : std::uint8_t {
  big,
  little
};

template <Endianess endianess = Endianess::big, typename V>
constexpr stream::IOStatus to_bytes(stream::OutputStream& stream, V&& data) {
  auto serializer = serializer::Binary{stream};
  serialize(serializer, std::forward<V>(data));
  return serializer.status;
}

template <Endianess endianess = Endianess::big, typename V>
constexpr std::vector<std::byte> to_bytes(V&& data) {
  auto buffer = std::vector<std::byte>();
  auto stream = stream::VectorOutputStream(buffer);
  auto serializer = serializer::Binary(stream);

  serialize(serializer, std::forward<V>(data));
  buffer.shrink_to_fit();
  return buffer;
}

}  // namespace rsl